<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">

<!--
`sortable-list`


@demo demo/index.html
-->

<dom-module id="sortable-list">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      ::slotted(*) {
        user-drag: none;
        user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
      }

      ::slotted(.item--transform) {
        left: 0;
        margin: 0 !important;
        position: fixed !important;
        top: 0;
        transition: transform 0.2s cubic-bezier(0.333, 0, 0, 1);
        will-change: transform;
        z-index: 1;
      }

      ::slotted(.item--no-transition) {
        transition: none !important;
      }

      ::slotted(.item--dragging) {
        -webkit-box-shadow: 0 2px 10px rgba(0,0,0,.2);
        box-shadow: 0 2px 10px rgba(0,0,0,.2);
        filter: brightness(1.1);
        z-index: 2;
      }
    </style>
    
    <div
        id="items"
        on-track="_onTrack"
        on-dragstart="_onDragStart"
        on-transitionend="_onTransitionEnd">
      <slot id="slot"></slot>
    </div>

  </template>

  <script>

    class SortableList extends Polymer.GestureEventListeners(Polymer.Element) {

      static get is() {return 'sortable-list';}

      static get properties() {
        return {

          /**
          * This is a CSS selector string. If this is set, only items that match
          * the CSS selector are sortable.
          */
          selectable: String,

          /**
          * The list of sortable items.
          */
          items: {
            type: Array,
            notify: true,
            readOnly: true
          },

          /**
          * Returns true when an item is being drag.
          */
          dragging: {
            type: Boolean,
            notify: true,
            readOnly: true,
            reflectToAttribute: true,
            value: false
          },

          /**
          * Whether the sorting is possible.
          */
          disabled: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          }

        };
      }

      constructor() {
        super();
        this._observer = null;
        this._target = null;
        this._targetRect = null;
        this._rects = null;
      }

      connectedCallback() {
        super.connectedCallback();
        requestAnimationFrame(_ => {
          this._observeItems();
          this._updateItems();
        });
      } 

      disconnectedCallback() {
        super.disconnectedCallback();
        this._unobserveItems();
      } 

      _onTrack(event) {
        switch(event.detail.state) {
          case 'start': this._trackStart(event); break;
          case 'track': this._track(event); break;
          case 'end': this._trackEnd(event); break;
        }
      }

      _trackStart(event) {
        if (this.disabled) {
          return;
        }
        this._target = this._itemFromEvent(event);
        if (!this._target) {
          return;
        }
        event.stopPropagation();
        this._rects = this._getItemsRects();
        this._targetRect = this._rects[this.items.indexOf(this._target)];
        this._target.classList.add('item--dragging');
        this._target.classList.add('item--no-transition');
        if ('vibrate' in navigator) {
          navigator.vibrate(30);
        }
        this.style.height = this.getBoundingClientRect().height + 'px';
        this.items.forEach((item, idx) => {
          const rect = this._rects[idx];
          item.classList.add('item--transform');
          item.style.transition = 'none';
          this._translate3d(rect.left, rect.top, 1, item);
          setTimeout(_ => {
            item.style.transition = null;
          });
        });
        this._setDragging(true);
      }

      _track(event) {
        if (!this.dragging) {
          return;
        }
        const left = this._targetRect.left + event.detail.dx;
        const top = this._targetRect.top + event.detail.dy;
        this._translate3d(left, top, 1, this._target);
        const overItem = this._itemFromCoords(event.detail);
        if (overItem && overItem !== this._target) {
          const overItemIndex = this.items.indexOf(overItem);
          const targetIndex = this.items.indexOf(this._target);
          this._moveItemArray(this.items, targetIndex, overItemIndex);
          for(let i = 0; i < this.items.length; i++) {
            if (this.items[i] !== this._target) {
              requestAnimationFrame(_ => {
                const rect = this._rects[i];
                this._translate3d(rect.left, rect.top, 1, this.items[i]);
              });
            }
          }
        }
      }

      // The track really ends
      _trackEnd(event) {
        if (!this.dragging) {
          return;
        }
        const rect = this._rects[this.items.indexOf(this._target)];
        this._target.classList.remove('item--no-transition');
        requestAnimationFrame(_ => {
          this._setDragging(false);
          this._translate3d(rect.left, rect.top, 1, this._target);
        });
      }

      _onDragStart(event) {
        if (event.composedPath()[0] !== this) {
          event.preventDefault();
        }
      }

      _onTransitionEnd() {
        if (this.dragging || !this._target) {
          return;
        }
        const fragment = document.createDocumentFragment();
        this.items.forEach(item => {
          item.style.transform = '';
          item.classList.remove('item--transform');
          fragment.appendChild(item);
        });
        if (this.children[0]) {
          this.insertBefore(fragment, this.children[0]);
        } else {
          this.appendChild(fragment);
        }
        this.style.height = '';
        this._target.classList.remove('item--dragging');
        this._rects = null;
        this._target = null;
        this._targetRect = null;
        this._updateItems();
        this.dispatchEvent(new CustomEvent('sort-finish', {
          composed: true
        }));
      }

      /**
       * Updates the items array.
       */
      _updateItems() {
        if (this.dragging) {
          return;
        }
        const items = this.$.slot.assignedNodes().filter(node => {
          if ((node.nodeType === Node.ELEMENT_NODE) &&
              (!this.selectable || node.matches(this.selectable))) {
            return true;
          }
        });
        this._setItems(items);
      }

      _itemFromCoords({x, y}) {
        if (!this._rects) {return;}
        let match = null;
        this._rects.forEach((rect, i) => {
          if (x >=rect.left && x <= rect.left + rect.width
            && y >= rect.top && y <= rect.top + rect.height) {
              match = this.items[i];
            }
        });
        return match;
      }

      _itemFromEvent(event) {
        const path = event.composedPath();
        for (var i = 0; i < path.length; i++) {
          if (this.items.indexOf(path[i]) > -1) {
            return path[i];
          }
        }
      }

      _getItemsRects() {
        return this.items.map(item => {
          return item.getBoundingClientRect();
        })
      }

      _observeItems() {
        if (!this._observer) {
          this._observer = new MutationObserver(_ => {
            this._updateItems();
          });
          this._observer.observe(this, {childList: true});
        }
      }

      _unobserveItems() {
        if (this._observer) {
          this._observer.disconnect();
          this._observer = null;
        }
      }

      /**
       * Move an array item from one position to another.     
       * Source: http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
       */
      _moveItemArray(array, oldIndex, newIndex) {
        if (newIndex >= array.length) {
          var k = newIndex - array.length;
          while ((k--) + 1) {
          array.push(undefined);
          }
        }
        array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
        return array;
      }

      _translate3d(x, y, z, el) {
        el.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
      }

    }

    customElements.define(SortableList.is, SortableList);

  </script>
</dom-module>