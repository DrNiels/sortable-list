<link rel="import" href="../polymer/polymer.html">

<!--
`sortable-list`


@demo demo/index.html 
-->

<dom-module id="sortable-list">
  <template>
    <style>
      :host {
        display: block;
      }

      ::content * {
        user-drag: none;
        user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
      }

      :host([dragging]) {
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }

      ::content .drag-item {
        -webkit-box-shadow: 0 2px 10px rgba(0,0,0,.2);
        box-shadow: 0 2px 10px rgba(0,0,0,.2);
        left: 0;
        pointer-events: none !important;
        position: fixed !important;
        top: 0;
        z-index: 1;
      }

      ::content .clone-item {
        opacity: 0;
      }
    </style>

    <content></content>

  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({

    is: 'sortable-list',

    properties: {

      /**
       * This is a CSS selector string. If this is set, only items that match the CSS selector
       * are sortable.
       */
      selectable: String,

      /**
       * The list of sortable items.
       */      
      items: {
        type: Array,
        notify: true,
        readOnly: true
      },

      /**
       * Returns true when an item is being drag.
       */
      dragging: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        readOnly: true,
        value: false
      },

      /**
       * Whether the sort is possible.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }

    },

    listeners: {
      'pointerdown': '_trackEvent',
      'pointermove': '_trackEvent',
      'pointerup': '_trackEvent',
      'touchmove': '_trackEvent',
      'touchend': '_trackEvent'      
    },

    attached() {
      this._observer = this._observeItems(this);
      this._updateItems();
    },

    detached: function() {
      if (this._observer) {
        Polymer.dom(this).unobserveNodes(this._observer);
      }
    },

    getItemFromEvent(event) {
      let node = event.target;
      let target;

      while(node && node !== this) {
        if (this.items.indexOf(node) >= 0) {
          target = node;
          break;
        }
        node = node.parentNode;
      }

      return target;
    },

    _trackEvent(event) {
      switch(event.type) {
        case 'pointerdown':
          // Keep initial pointer coordinates for later use.
          this._startX = event.clientX;
          this._startY = event.clientY;
          this._target = this.getItemFromEvent(event);
          // this._dragReady = true;

          // if (event.eventType !== 'mouse') {
          //   this._dragReady = false;

          //   setTimeout(_ => {
          //     const dx = this._dragDetail.dx;
          //     const dy = this._dragDetail.dy;
          //     console.log(dx, dy);
              
          //     // Using touch, it's only draggable when pressing the same posistion
          //     // for a safe time.
          //     if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
          //       this._dragReady = true;
          //     }
          //   }, 70);
          // }
          break;
        case 'pointermove':
        case 'touchmove':
          if (typeof this._startX !== 'number' || this.disabled) {
            break;
          }

          const x = event.touches ? event.touches[0].clientX : event.clientX;
          const y = event.touches ? event.touches[0].clientY : event.clientY;
          const dx = x - this._startX;
          const dy = y - this._startY;

          // this._dragDetail = {x, y, dx, dy};

          // if (!this._dragReady) {
          //   return;
          // }

          Object.defineProperty(event, 'detail', {
            get: _ => {
              return {x, y, dx, dy};
            }
          });

          if (this.dragging) {
            this._drag(event);
          } else {
            // Don't start dragging until the mouse/finger has moved a bit
            if (Math.abs(dx) > 8 || Math.abs(dy) > 8) {
              this._setDragging(true);
              this._dragStart(event);
            }
          }
          break;
        case 'pointerup':
        case 'touchend':
          if (this.dragging) {
            this._setDragging(false);
            this._dragEnd(event);
          }
          this._startX = null;
          this._startY = null;
          this._target = null;
          break;
      }
    },

    _dragStart(event) {
      this._targetRect = this._target.getBoundingClientRect();
      this._updateItemsRects();

      // Place clone at target position
      this._clone = this._target.cloneNode(true);
      this._clone.classList.add('clone-item');
      Polymer.dom(this).insertBefore(this._clone, this._target);

      // Move target
      this._target.classList.add('drag-item');
      this.translate3d(`${this._targetRect.left}px`, `${this._targetRect.top}px`, '1px', this._target);
    },

    _drag(event) {
      event.preventDefault();

      const x = this._targetRect.left + event.detail.dx;
      const y = this._targetRect.top + event.detail.dy;

      this.translate3d(`${x}px`, `${y}px`, '1px', this._target);

      const overItem = this._itemWithinBounds(event.detail);

      if (overItem) {
        const overItemIndex = this.items.indexOf(overItem);
        const targetIndex = this.items.indexOf(this._target);

        if (targetIndex > overItemIndex) {
          Polymer.dom(this).insertBefore(this._clone, overItem);
        } else {
          Polymer.dom(this).insertBefore(this._clone, overItem.nextSibling);
        }

        this._updateItemsRects();
      } 
    },

    _dragEnd(event) {
      Polymer.dom(this).insertBefore(this._target, this._clone);
      Polymer.dom(this._clone.parentNode).removeChild(this._clone);
      this._clone = null;
      this._target.style.transform = '';
      this._target.classList.remove('drag-item');
      this._targetRect = null;
      this._rects = null;
      this.fire('sort-list');
    },

    /**
     * Observer items under the given node.
     *
     * @param {!HTMLElement} node
     */
    _observeItems: function(node) {
      return Polymer.dom(node).observeNodes(mutation => {
        this._updateItems();
      });
    },

    _updateItems: function() {
      let nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
      nodes = nodes.filter(node => {
        return node.localName !== 'template' && !node.matches('.item-clone');
      });
      this._setItems(nodes);
    },

    _updateItemsRects: function() {
      const rects = new Map();
      for (let i = 0; i < this.items.length; i++) {
        const rect = this.items[i].getBoundingClientRect();
        rects.set(this.items[i], rect);
      }
      this._rects = rects;
    },

    _itemWithinBounds({x,y}) {
      let match = null;

      this._rects.forEach((rect, item) => {
        if (item.classList.contains('drag-item')) {
          return;
        }
        if (x >=rect.left && x <= rect.left + rect.width
          && y >= rect.top && y <= rect.top + rect.height) {
            match = item;
          }
      });

      return match;
    }

  });

}());
</script>
