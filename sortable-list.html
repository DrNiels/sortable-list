<link rel="import" href="../polymer/polymer.html">


<!--
`sortable-list`


@demo demo/index.html 
-->

<dom-module id="sortable-list">
  <template>
    <style>
      :host {
        display: block;
      }

      ::content  * {
        user-drag: none; 
        user-select: none;
        -moz-user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
        -ms-user-select: none;        
      }

      :host([dragging]) { 
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }

      ::content .drag-item {
        -webkit-box-shadow: 0 2px 10px rgba(0,0,0,.2);
        box-shadow: 0 2px 10px rgba(0,0,0,.2);
        left: 0;
        pointer-events: none !important;
        position: fixed !important;
        top: 0;
        z-index: 1;
      }

      ::content .clone-item {
        opacity: 0;
      }
    </style>

    <content></content>

  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({

    is: 'sortable-list',

    properties: {

      /**
       * This is a CSS selector string. If this is set, only items that match the CSS selector
       * are sortable.
       */
      selectable: String,

      /**
       * The list of sortable items.
       */      
      items: {
        type: Array,
        notify: true,
        readOnly: true
      },

      /**
       * Returns true when an item is being drag.
       */
      dragging: {
        type: Boolean,
        reflectToAttribute: true,
        readOnly: true,
        value: false
      },

      /**
       * Whether the sort is possible.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }

    },

    listeners: {
      'track': '_onTrack'
    },

    attached() {
      this._observer = this._observeItems(this);
      this._updateItems();
    },

    detached: function() {
      if (this._observer) {
        Polymer.dom(this).unobserveNodes(this._observer);
      }
    },

    getItemFromEvent(event) {
      let node = event.target;
      let target;

      while(node && node !== this) {
        if (this.items.indexOf(node) >= 0) {
          target = node;
          break;
        }
        node = node.parentNode;
      }

      return target;
    },

    _onTrack(event) {
      if (this.disabled) {
        return;
      }

      const target = this.getItemFromEvent(event);
      let node = event.target;
      if (!target) {
        return;
      }

      Object.defineProperty(event, 'target', {
        get: _ => target
      });

      const customEvent = this.fire('sortable-list-track', {
        trackEvent: event
      }, {
        bubbles: true,
        cancelable: true
      });

      if (customEvent.defaultPrevented) {
        return;
      }
    
      switch (event.detail.state) {
        case 'start': this._trackStart(event); break;
        case 'track': this._track(event); break;
        case 'end': this._trackEnd(event); break;
      }
    },

    _trackStart(event) {
      // Cache drag details
      this._startX = event.detail.x;
      this._startY = event.detail.y;
      this._target = event.target;
      this._targetRect = event.target.getBoundingClientRect();
      this._updateItemsRects();

      // Place clone at target position
      this._clone = this._target.cloneNode(true);
      this._clone.classList.add('clone-item');
      Polymer.dom(this).insertBefore(this._clone, this._target);

      // Move target
      this._target.classList.add('drag-item');
      this.translate3d(`${this._targetRect.left}px`, `${this._targetRect.top}px`, '1px', this._target);

      this._setDragging(true);
    },

    _track(event) {
      const x = this._targetRect.left + event.detail.x - this._startX;
      const y = this._targetRect.top + event.detail.y - this._startY;

      this.translate3d(`${x}px`, `${y}px`, '1px', this._target);

      const overItem = this._itemWithinBounds(event.detail);

      if (overItem) {
        const overItemIndex = this.items.indexOf(overItem);
        const targetIndex = this.items.indexOf(this._target);


        if (targetIndex > overItemIndex) {
          Polymer.dom(this).insertBefore(this._clone, overItem);
        } else {
          Polymer.dom(this).insertBefore(this._clone, overItem.nextSibling);
        }

        this._updateItemsRects();
      } 
    },

    _trackEnd(event) {
      Polymer.dom(this).insertBefore(this._target, this._clone);
      Polymer.dom(this._clone.parentNode).removeChild(this._clone);
      this._clone = null;
      this._target.style.transform = '';
      this._target.classList.remove('drag-item');
      this._target = null;
      this._targetRect = null;
      this._rects = null;
      this._startX = null;
      this._startY = null;
      this._setDragging(false);

      this.fire('sort-list');
    },

    /**
     * Observer items under the given node.
     *
     * @param {!HTMLElement} node
     */
    _observeItems: function(node) {
      return Polymer.dom(node).observeNodes(mutation => {
        this._updateItems();
      });
    },

    _updateItems: function() {
      let nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
      nodes = nodes.filter(node => {
        return node.localName !== 'template' && !node.matches('.item-clone');
      });
      this._setItems(nodes);
    },

    _updateItemsRects: function() {
      const rects = new Map();
      for (let i = 0; i < this.items.length; i++) {
        const rect = this.items[i].getBoundingClientRect();
        rects.set(this.items[i], rect);
      }
      this._rects = rects;
    },

    _itemWithinBounds({x,y}) {
      let match = null;

      this._rects.forEach((rect, item) => {
        if (item.classList.contains('drag-item')) {
          return;
        }
        if (x >=rect.left && x <= rect.left + rect.width
          && y >= rect.top && y <= rect.top + rect.height) {
            match = item;
          }
      });

      return match;
    }

  });

}());
</script>
